// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_msg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_msg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_msg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_msg_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_msg_2eproto;
namespace MyGame {
class Msg;
struct MsgDefaultTypeInternal;
extern MsgDefaultTypeInternal _Msg_default_instance_;
class MsgHead;
struct MsgHeadDefaultTypeInternal;
extern MsgHeadDefaultTypeInternal _MsgHead_default_instance_;
class MsgRsp;
struct MsgRspDefaultTypeInternal;
extern MsgRspDefaultTypeInternal _MsgRsp_default_instance_;
class MsgRspHead;
struct MsgRspHeadDefaultTypeInternal;
extern MsgRspHeadDefaultTypeInternal _MsgRspHead_default_instance_;
class RequestAct;
struct RequestActDefaultTypeInternal;
extern RequestActDefaultTypeInternal _RequestAct_default_instance_;
class RequestLogin;
struct RequestLoginDefaultTypeInternal;
extern RequestLoginDefaultTypeInternal _RequestLogin_default_instance_;
class RequestLogout;
struct RequestLogoutDefaultTypeInternal;
extern RequestLogoutDefaultTypeInternal _RequestLogout_default_instance_;
class ResponseAct;
struct ResponseActDefaultTypeInternal;
extern ResponseActDefaultTypeInternal _ResponseAct_default_instance_;
class ResponseLogin;
struct ResponseLoginDefaultTypeInternal;
extern ResponseLoginDefaultTypeInternal _ResponseLogin_default_instance_;
class ResponseLogout;
struct ResponseLogoutDefaultTypeInternal;
extern ResponseLogoutDefaultTypeInternal _ResponseLogout_default_instance_;
}  // namespace MyGame
PROTOBUF_NAMESPACE_OPEN
template<> ::MyGame::Msg* Arena::CreateMaybeMessage<::MyGame::Msg>(Arena*);
template<> ::MyGame::MsgHead* Arena::CreateMaybeMessage<::MyGame::MsgHead>(Arena*);
template<> ::MyGame::MsgRsp* Arena::CreateMaybeMessage<::MyGame::MsgRsp>(Arena*);
template<> ::MyGame::MsgRspHead* Arena::CreateMaybeMessage<::MyGame::MsgRspHead>(Arena*);
template<> ::MyGame::RequestAct* Arena::CreateMaybeMessage<::MyGame::RequestAct>(Arena*);
template<> ::MyGame::RequestLogin* Arena::CreateMaybeMessage<::MyGame::RequestLogin>(Arena*);
template<> ::MyGame::RequestLogout* Arena::CreateMaybeMessage<::MyGame::RequestLogout>(Arena*);
template<> ::MyGame::ResponseAct* Arena::CreateMaybeMessage<::MyGame::ResponseAct>(Arena*);
template<> ::MyGame::ResponseLogin* Arena::CreateMaybeMessage<::MyGame::ResponseLogin>(Arena*);
template<> ::MyGame::ResponseLogout* Arena::CreateMaybeMessage<::MyGame::ResponseLogout>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace MyGame {

enum MsgType : int {
  MsgType_Default = 0,
  MsgType_Login = 1,
  MsgType_Logout = 2,
  MsgType_Act = 3,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgType_IsValid(int value);
constexpr MsgType MsgType_MIN = MsgType_Default;
constexpr MsgType MsgType_MAX = MsgType_Act;
constexpr int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor();
template<typename T>
inline const std::string& MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgType_descriptor(), enum_t_value);
}
inline bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum MsgErrCode : int {
  MsgErr_OK = 0,
  MsgErr_Fail = 1,
  MsgErr_NotExist = 2,
  MsgErr_PasswdWrong = 3,
  MsgErrCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgErrCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgErrCode_IsValid(int value);
constexpr MsgErrCode MsgErrCode_MIN = MsgErr_OK;
constexpr MsgErrCode MsgErrCode_MAX = MsgErr_PasswdWrong;
constexpr int MsgErrCode_ARRAYSIZE = MsgErrCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgErrCode_descriptor();
template<typename T>
inline const std::string& MsgErrCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgErrCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgErrCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgErrCode_descriptor(), enum_t_value);
}
inline bool MsgErrCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgErrCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgErrCode>(
    MsgErrCode_descriptor(), name, value);
}
// ===================================================================

class MsgHead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MyGame.MsgHead) */ {
 public:
  inline MsgHead() : MsgHead(nullptr) {}
  ~MsgHead() override;
  explicit PROTOBUF_CONSTEXPR MsgHead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgHead(const MsgHead& from);
  MsgHead(MsgHead&& from) noexcept
    : MsgHead() {
    *this = ::std::move(from);
  }

  inline MsgHead& operator=(const MsgHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgHead& operator=(MsgHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgHead* internal_default_instance() {
    return reinterpret_cast<const MsgHead*>(
               &_MsgHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgHead& a, MsgHead& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgHead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgHead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgHead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MsgHead& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgHead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MyGame.MsgHead";
  }
  protected:
  explicit MsgHead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .MyGame.MsgType type = 1;
  void clear_type();
  ::MyGame::MsgType type() const;
  void set_type(::MyGame::MsgType value);
  private:
  ::MyGame::MsgType _internal_type() const;
  void _internal_set_type(::MyGame::MsgType value);
  public:

  // @@protoc_insertion_point(class_scope:MyGame.MsgHead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class MsgRspHead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MyGame.MsgRspHead) */ {
 public:
  inline MsgRspHead() : MsgRspHead(nullptr) {}
  ~MsgRspHead() override;
  explicit PROTOBUF_CONSTEXPR MsgRspHead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgRspHead(const MsgRspHead& from);
  MsgRspHead(MsgRspHead&& from) noexcept
    : MsgRspHead() {
    *this = ::std::move(from);
  }

  inline MsgRspHead& operator=(const MsgRspHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgRspHead& operator=(MsgRspHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgRspHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgRspHead* internal_default_instance() {
    return reinterpret_cast<const MsgRspHead*>(
               &_MsgRspHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MsgRspHead& a, MsgRspHead& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgRspHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgRspHead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgRspHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgRspHead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgRspHead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MsgRspHead& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgRspHead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MyGame.MsgRspHead";
  }
  protected:
  explicit MsgRspHead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kResFieldNumber = 2,
  };
  // .MyGame.MsgType type = 1;
  void clear_type();
  ::MyGame::MsgType type() const;
  void set_type(::MyGame::MsgType value);
  private:
  ::MyGame::MsgType _internal_type() const;
  void _internal_set_type(::MyGame::MsgType value);
  public:

  // .MyGame.MsgErrCode res = 2;
  void clear_res();
  ::MyGame::MsgErrCode res() const;
  void set_res(::MyGame::MsgErrCode value);
  private:
  ::MyGame::MsgErrCode _internal_res() const;
  void _internal_set_res(::MyGame::MsgErrCode value);
  public:

  // @@protoc_insertion_point(class_scope:MyGame.MsgRspHead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  int res_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class RequestLogin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MyGame.RequestLogin) */ {
 public:
  inline RequestLogin() : RequestLogin(nullptr) {}
  ~RequestLogin() override;
  explicit PROTOBUF_CONSTEXPR RequestLogin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestLogin(const RequestLogin& from);
  RequestLogin(RequestLogin&& from) noexcept
    : RequestLogin() {
    *this = ::std::move(from);
  }

  inline RequestLogin& operator=(const RequestLogin& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestLogin& operator=(RequestLogin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestLogin& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestLogin* internal_default_instance() {
    return reinterpret_cast<const RequestLogin*>(
               &_RequestLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RequestLogin& a, RequestLogin& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestLogin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestLogin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestLogin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestLogin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestLogin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestLogin& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestLogin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MyGame.RequestLogin";
  }
  protected:
  explicit RequestLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrNameFieldNumber = 1,
    kStrPassFieldNumber = 2,
  };
  // string strName = 1;
  void clear_strname();
  const std::string& strname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strname();
  PROTOBUF_NODISCARD std::string* release_strname();
  void set_allocated_strname(std::string* strname);
  private:
  const std::string& _internal_strname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strname(const std::string& value);
  std::string* _internal_mutable_strname();
  public:

  // string strPass = 2;
  void clear_strpass();
  const std::string& strpass() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strpass(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strpass();
  PROTOBUF_NODISCARD std::string* release_strpass();
  void set_allocated_strpass(std::string* strpass);
  private:
  const std::string& _internal_strpass() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strpass(const std::string& value);
  std::string* _internal_mutable_strpass();
  public:

  // @@protoc_insertion_point(class_scope:MyGame.RequestLogin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strpass_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ResponseLogin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MyGame.ResponseLogin) */ {
 public:
  inline ResponseLogin() : ResponseLogin(nullptr) {}
  ~ResponseLogin() override;
  explicit PROTOBUF_CONSTEXPR ResponseLogin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseLogin(const ResponseLogin& from);
  ResponseLogin(ResponseLogin&& from) noexcept
    : ResponseLogin() {
    *this = ::std::move(from);
  }

  inline ResponseLogin& operator=(const ResponseLogin& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseLogin& operator=(ResponseLogin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseLogin& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseLogin* internal_default_instance() {
    return reinterpret_cast<const ResponseLogin*>(
               &_ResponseLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ResponseLogin& a, ResponseLogin& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseLogin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseLogin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseLogin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseLogin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseLogin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseLogin& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseLogin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MyGame.ResponseLogin";
  }
  protected:
  explicit ResponseLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
    kRoleLevelFieldNumber = 2,
  };
  // int32 roleId = 1;
  void clear_roleid();
  int32_t roleid() const;
  void set_roleid(int32_t value);
  private:
  int32_t _internal_roleid() const;
  void _internal_set_roleid(int32_t value);
  public:

  // int32 roleLevel = 2;
  void clear_rolelevel();
  int32_t rolelevel() const;
  void set_rolelevel(int32_t value);
  private:
  int32_t _internal_rolelevel() const;
  void _internal_set_rolelevel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MyGame.ResponseLogin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t roleid_;
  int32_t rolelevel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class RequestLogout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MyGame.RequestLogout) */ {
 public:
  inline RequestLogout() : RequestLogout(nullptr) {}
  ~RequestLogout() override;
  explicit PROTOBUF_CONSTEXPR RequestLogout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestLogout(const RequestLogout& from);
  RequestLogout(RequestLogout&& from) noexcept
    : RequestLogout() {
    *this = ::std::move(from);
  }

  inline RequestLogout& operator=(const RequestLogout& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestLogout& operator=(RequestLogout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestLogout& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestLogout* internal_default_instance() {
    return reinterpret_cast<const RequestLogout*>(
               &_RequestLogout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestLogout& a, RequestLogout& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestLogout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestLogout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestLogout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestLogout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestLogout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestLogout& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestLogout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MyGame.RequestLogout";
  }
  protected:
  explicit RequestLogout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
  };
  // int32 roleId = 1;
  void clear_roleid();
  int32_t roleid() const;
  void set_roleid(int32_t value);
  private:
  int32_t _internal_roleid() const;
  void _internal_set_roleid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MyGame.RequestLogout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t roleid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ResponseLogout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MyGame.ResponseLogout) */ {
 public:
  inline ResponseLogout() : ResponseLogout(nullptr) {}
  ~ResponseLogout() override;
  explicit PROTOBUF_CONSTEXPR ResponseLogout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseLogout(const ResponseLogout& from);
  ResponseLogout(ResponseLogout&& from) noexcept
    : ResponseLogout() {
    *this = ::std::move(from);
  }

  inline ResponseLogout& operator=(const ResponseLogout& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseLogout& operator=(ResponseLogout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseLogout& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseLogout* internal_default_instance() {
    return reinterpret_cast<const ResponseLogout*>(
               &_ResponseLogout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResponseLogout& a, ResponseLogout& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseLogout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseLogout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseLogout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseLogout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseLogout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseLogout& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseLogout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MyGame.ResponseLogout";
  }
  protected:
  explicit ResponseLogout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
  };
  // int32 roleId = 1;
  void clear_roleid();
  int32_t roleid() const;
  void set_roleid(int32_t value);
  private:
  int32_t _internal_roleid() const;
  void _internal_set_roleid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MyGame.ResponseLogout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t roleid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class RequestAct final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MyGame.RequestAct) */ {
 public:
  inline RequestAct() : RequestAct(nullptr) {}
  ~RequestAct() override;
  explicit PROTOBUF_CONSTEXPR RequestAct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestAct(const RequestAct& from);
  RequestAct(RequestAct&& from) noexcept
    : RequestAct() {
    *this = ::std::move(from);
  }

  inline RequestAct& operator=(const RequestAct& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestAct& operator=(RequestAct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestAct& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestAct* internal_default_instance() {
    return reinterpret_cast<const RequestAct*>(
               &_RequestAct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RequestAct& a, RequestAct& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestAct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestAct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestAct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestAct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestAct& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestAct& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestAct* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MyGame.RequestAct";
  }
  protected:
  explicit RequestAct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
  };
  // string action = 1;
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // @@protoc_insertion_point(class_scope:MyGame.RequestAct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class ResponseAct final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MyGame.ResponseAct) */ {
 public:
  inline ResponseAct() : ResponseAct(nullptr) {}
  ~ResponseAct() override;
  explicit PROTOBUF_CONSTEXPR ResponseAct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseAct(const ResponseAct& from);
  ResponseAct(ResponseAct&& from) noexcept
    : ResponseAct() {
    *this = ::std::move(from);
  }

  inline ResponseAct& operator=(const ResponseAct& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseAct& operator=(ResponseAct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseAct& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseAct* internal_default_instance() {
    return reinterpret_cast<const ResponseAct*>(
               &_ResponseAct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ResponseAct& a, ResponseAct& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseAct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseAct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseAct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseAct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseAct& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseAct& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseAct* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MyGame.ResponseAct";
  }
  protected:
  explicit ResponseAct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
  };
  // string action = 1;
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // @@protoc_insertion_point(class_scope:MyGame.ResponseAct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class Msg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MyGame.Msg) */ {
 public:
  inline Msg() : Msg(nullptr) {}
  ~Msg() override;
  explicit PROTOBUF_CONSTEXPR Msg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Msg(const Msg& from);
  Msg(Msg&& from) noexcept
    : Msg() {
    *this = ::std::move(from);
  }

  inline Msg& operator=(const Msg& from) {
    CopyFrom(from);
    return *this;
  }
  inline Msg& operator=(Msg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Msg& default_instance() {
    return *internal_default_instance();
  }
  static inline const Msg* internal_default_instance() {
    return reinterpret_cast<const Msg*>(
               &_Msg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Msg& a, Msg& b) {
    a.Swap(&b);
  }
  inline void Swap(Msg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Msg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Msg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Msg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Msg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Msg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Msg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MyGame.Msg";
  }
  protected:
  explicit Msg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
    kPayloadFieldNumber = 2,
  };
  // .MyGame.MsgHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::MyGame::MsgHead& head() const;
  PROTOBUF_NODISCARD ::MyGame::MsgHead* release_head();
  ::MyGame::MsgHead* mutable_head();
  void set_allocated_head(::MyGame::MsgHead* head);
  private:
  const ::MyGame::MsgHead& _internal_head() const;
  ::MyGame::MsgHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::MyGame::MsgHead* head);
  ::MyGame::MsgHead* unsafe_arena_release_head();

  // .google.protobuf.Any payload = 2;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::PROTOBUF_NAMESPACE_ID::Any& payload() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_payload();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_payload();
  void set_allocated_payload(::PROTOBUF_NAMESPACE_ID::Any* payload);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_payload() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::PROTOBUF_NAMESPACE_ID::Any* payload);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_payload();

  // @@protoc_insertion_point(class_scope:MyGame.Msg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::MyGame::MsgHead* head_;
  ::PROTOBUF_NAMESPACE_ID::Any* payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class MsgRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MyGame.MsgRsp) */ {
 public:
  inline MsgRsp() : MsgRsp(nullptr) {}
  ~MsgRsp() override;
  explicit PROTOBUF_CONSTEXPR MsgRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgRsp(const MsgRsp& from);
  MsgRsp(MsgRsp&& from) noexcept
    : MsgRsp() {
    *this = ::std::move(from);
  }

  inline MsgRsp& operator=(const MsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgRsp& operator=(MsgRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgRsp* internal_default_instance() {
    return reinterpret_cast<const MsgRsp*>(
               &_MsgRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MsgRsp& a, MsgRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MsgRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MyGame.MsgRsp";
  }
  protected:
  explicit MsgRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
    kPayloadFieldNumber = 2,
  };
  // .MyGame.MsgRspHead head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::MyGame::MsgRspHead& head() const;
  PROTOBUF_NODISCARD ::MyGame::MsgRspHead* release_head();
  ::MyGame::MsgRspHead* mutable_head();
  void set_allocated_head(::MyGame::MsgRspHead* head);
  private:
  const ::MyGame::MsgRspHead& _internal_head() const;
  ::MyGame::MsgRspHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::MyGame::MsgRspHead* head);
  ::MyGame::MsgRspHead* unsafe_arena_release_head();

  // .google.protobuf.Any payload = 2;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::PROTOBUF_NAMESPACE_ID::Any& payload() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_payload();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_payload();
  void set_allocated_payload(::PROTOBUF_NAMESPACE_ID::Any* payload);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_payload() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::PROTOBUF_NAMESPACE_ID::Any* payload);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_payload();

  // @@protoc_insertion_point(class_scope:MyGame.MsgRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::MyGame::MsgRspHead* head_;
  ::PROTOBUF_NAMESPACE_ID::Any* payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MsgHead

// .MyGame.MsgType type = 1;
inline void MsgHead::clear_type() {
  type_ = 0;
}
inline ::MyGame::MsgType MsgHead::_internal_type() const {
  return static_cast< ::MyGame::MsgType >(type_);
}
inline ::MyGame::MsgType MsgHead::type() const {
  // @@protoc_insertion_point(field_get:MyGame.MsgHead.type)
  return _internal_type();
}
inline void MsgHead::_internal_set_type(::MyGame::MsgType value) {
  
  type_ = value;
}
inline void MsgHead::set_type(::MyGame::MsgType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:MyGame.MsgHead.type)
}

// -------------------------------------------------------------------

// MsgRspHead

// .MyGame.MsgType type = 1;
inline void MsgRspHead::clear_type() {
  type_ = 0;
}
inline ::MyGame::MsgType MsgRspHead::_internal_type() const {
  return static_cast< ::MyGame::MsgType >(type_);
}
inline ::MyGame::MsgType MsgRspHead::type() const {
  // @@protoc_insertion_point(field_get:MyGame.MsgRspHead.type)
  return _internal_type();
}
inline void MsgRspHead::_internal_set_type(::MyGame::MsgType value) {
  
  type_ = value;
}
inline void MsgRspHead::set_type(::MyGame::MsgType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:MyGame.MsgRspHead.type)
}

// .MyGame.MsgErrCode res = 2;
inline void MsgRspHead::clear_res() {
  res_ = 0;
}
inline ::MyGame::MsgErrCode MsgRspHead::_internal_res() const {
  return static_cast< ::MyGame::MsgErrCode >(res_);
}
inline ::MyGame::MsgErrCode MsgRspHead::res() const {
  // @@protoc_insertion_point(field_get:MyGame.MsgRspHead.res)
  return _internal_res();
}
inline void MsgRspHead::_internal_set_res(::MyGame::MsgErrCode value) {
  
  res_ = value;
}
inline void MsgRspHead::set_res(::MyGame::MsgErrCode value) {
  _internal_set_res(value);
  // @@protoc_insertion_point(field_set:MyGame.MsgRspHead.res)
}

// -------------------------------------------------------------------

// RequestLogin

// string strName = 1;
inline void RequestLogin::clear_strname() {
  strname_.ClearToEmpty();
}
inline const std::string& RequestLogin::strname() const {
  // @@protoc_insertion_point(field_get:MyGame.RequestLogin.strName)
  return _internal_strname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestLogin::set_strname(ArgT0&& arg0, ArgT... args) {
 
 strname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MyGame.RequestLogin.strName)
}
inline std::string* RequestLogin::mutable_strname() {
  std::string* _s = _internal_mutable_strname();
  // @@protoc_insertion_point(field_mutable:MyGame.RequestLogin.strName)
  return _s;
}
inline const std::string& RequestLogin::_internal_strname() const {
  return strname_.Get();
}
inline void RequestLogin::_internal_set_strname(const std::string& value) {
  
  strname_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestLogin::_internal_mutable_strname() {
  
  return strname_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestLogin::release_strname() {
  // @@protoc_insertion_point(field_release:MyGame.RequestLogin.strName)
  return strname_.Release();
}
inline void RequestLogin::set_allocated_strname(std::string* strname) {
  if (strname != nullptr) {
    
  } else {
    
  }
  strname_.SetAllocated(strname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (strname_.IsDefault()) {
    strname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MyGame.RequestLogin.strName)
}

// string strPass = 2;
inline void RequestLogin::clear_strpass() {
  strpass_.ClearToEmpty();
}
inline const std::string& RequestLogin::strpass() const {
  // @@protoc_insertion_point(field_get:MyGame.RequestLogin.strPass)
  return _internal_strpass();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestLogin::set_strpass(ArgT0&& arg0, ArgT... args) {
 
 strpass_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MyGame.RequestLogin.strPass)
}
inline std::string* RequestLogin::mutable_strpass() {
  std::string* _s = _internal_mutable_strpass();
  // @@protoc_insertion_point(field_mutable:MyGame.RequestLogin.strPass)
  return _s;
}
inline const std::string& RequestLogin::_internal_strpass() const {
  return strpass_.Get();
}
inline void RequestLogin::_internal_set_strpass(const std::string& value) {
  
  strpass_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestLogin::_internal_mutable_strpass() {
  
  return strpass_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestLogin::release_strpass() {
  // @@protoc_insertion_point(field_release:MyGame.RequestLogin.strPass)
  return strpass_.Release();
}
inline void RequestLogin::set_allocated_strpass(std::string* strpass) {
  if (strpass != nullptr) {
    
  } else {
    
  }
  strpass_.SetAllocated(strpass, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (strpass_.IsDefault()) {
    strpass_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MyGame.RequestLogin.strPass)
}

// -------------------------------------------------------------------

// ResponseLogin

// int32 roleId = 1;
inline void ResponseLogin::clear_roleid() {
  roleid_ = 0;
}
inline int32_t ResponseLogin::_internal_roleid() const {
  return roleid_;
}
inline int32_t ResponseLogin::roleid() const {
  // @@protoc_insertion_point(field_get:MyGame.ResponseLogin.roleId)
  return _internal_roleid();
}
inline void ResponseLogin::_internal_set_roleid(int32_t value) {
  
  roleid_ = value;
}
inline void ResponseLogin::set_roleid(int32_t value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:MyGame.ResponseLogin.roleId)
}

// int32 roleLevel = 2;
inline void ResponseLogin::clear_rolelevel() {
  rolelevel_ = 0;
}
inline int32_t ResponseLogin::_internal_rolelevel() const {
  return rolelevel_;
}
inline int32_t ResponseLogin::rolelevel() const {
  // @@protoc_insertion_point(field_get:MyGame.ResponseLogin.roleLevel)
  return _internal_rolelevel();
}
inline void ResponseLogin::_internal_set_rolelevel(int32_t value) {
  
  rolelevel_ = value;
}
inline void ResponseLogin::set_rolelevel(int32_t value) {
  _internal_set_rolelevel(value);
  // @@protoc_insertion_point(field_set:MyGame.ResponseLogin.roleLevel)
}

// -------------------------------------------------------------------

// RequestLogout

// int32 roleId = 1;
inline void RequestLogout::clear_roleid() {
  roleid_ = 0;
}
inline int32_t RequestLogout::_internal_roleid() const {
  return roleid_;
}
inline int32_t RequestLogout::roleid() const {
  // @@protoc_insertion_point(field_get:MyGame.RequestLogout.roleId)
  return _internal_roleid();
}
inline void RequestLogout::_internal_set_roleid(int32_t value) {
  
  roleid_ = value;
}
inline void RequestLogout::set_roleid(int32_t value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:MyGame.RequestLogout.roleId)
}

// -------------------------------------------------------------------

// ResponseLogout

// int32 roleId = 1;
inline void ResponseLogout::clear_roleid() {
  roleid_ = 0;
}
inline int32_t ResponseLogout::_internal_roleid() const {
  return roleid_;
}
inline int32_t ResponseLogout::roleid() const {
  // @@protoc_insertion_point(field_get:MyGame.ResponseLogout.roleId)
  return _internal_roleid();
}
inline void ResponseLogout::_internal_set_roleid(int32_t value) {
  
  roleid_ = value;
}
inline void ResponseLogout::set_roleid(int32_t value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:MyGame.ResponseLogout.roleId)
}

// -------------------------------------------------------------------

// RequestAct

// string action = 1;
inline void RequestAct::clear_action() {
  action_.ClearToEmpty();
}
inline const std::string& RequestAct::action() const {
  // @@protoc_insertion_point(field_get:MyGame.RequestAct.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestAct::set_action(ArgT0&& arg0, ArgT... args) {
 
 action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MyGame.RequestAct.action)
}
inline std::string* RequestAct::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:MyGame.RequestAct.action)
  return _s;
}
inline const std::string& RequestAct::_internal_action() const {
  return action_.Get();
}
inline void RequestAct::_internal_set_action(const std::string& value) {
  
  action_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestAct::_internal_mutable_action() {
  
  return action_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestAct::release_action() {
  // @@protoc_insertion_point(field_release:MyGame.RequestAct.action)
  return action_.Release();
}
inline void RequestAct::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    
  } else {
    
  }
  action_.SetAllocated(action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_.IsDefault()) {
    action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MyGame.RequestAct.action)
}

// -------------------------------------------------------------------

// ResponseAct

// string action = 1;
inline void ResponseAct::clear_action() {
  action_.ClearToEmpty();
}
inline const std::string& ResponseAct::action() const {
  // @@protoc_insertion_point(field_get:MyGame.ResponseAct.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseAct::set_action(ArgT0&& arg0, ArgT... args) {
 
 action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MyGame.ResponseAct.action)
}
inline std::string* ResponseAct::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:MyGame.ResponseAct.action)
  return _s;
}
inline const std::string& ResponseAct::_internal_action() const {
  return action_.Get();
}
inline void ResponseAct::_internal_set_action(const std::string& value) {
  
  action_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseAct::_internal_mutable_action() {
  
  return action_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseAct::release_action() {
  // @@protoc_insertion_point(field_release:MyGame.ResponseAct.action)
  return action_.Release();
}
inline void ResponseAct::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    
  } else {
    
  }
  action_.SetAllocated(action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_.IsDefault()) {
    action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MyGame.ResponseAct.action)
}

// -------------------------------------------------------------------

// Msg

// .MyGame.MsgHead head = 1;
inline bool Msg::_internal_has_head() const {
  return this != internal_default_instance() && head_ != nullptr;
}
inline bool Msg::has_head() const {
  return _internal_has_head();
}
inline void Msg::clear_head() {
  if (GetArenaForAllocation() == nullptr && head_ != nullptr) {
    delete head_;
  }
  head_ = nullptr;
}
inline const ::MyGame::MsgHead& Msg::_internal_head() const {
  const ::MyGame::MsgHead* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::MyGame::MsgHead&>(
      ::MyGame::_MsgHead_default_instance_);
}
inline const ::MyGame::MsgHead& Msg::head() const {
  // @@protoc_insertion_point(field_get:MyGame.Msg.head)
  return _internal_head();
}
inline void Msg::unsafe_arena_set_allocated_head(
    ::MyGame::MsgHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MyGame.Msg.head)
}
inline ::MyGame::MsgHead* Msg::release_head() {
  
  ::MyGame::MsgHead* temp = head_;
  head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MyGame::MsgHead* Msg::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:MyGame.Msg.head)
  
  ::MyGame::MsgHead* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::MyGame::MsgHead* Msg::_internal_mutable_head() {
  
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::MyGame::MsgHead>(GetArenaForAllocation());
    head_ = p;
  }
  return head_;
}
inline ::MyGame::MsgHead* Msg::mutable_head() {
  ::MyGame::MsgHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:MyGame.Msg.head)
  return _msg;
}
inline void Msg::set_allocated_head(::MyGame::MsgHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:MyGame.Msg.head)
}

// .google.protobuf.Any payload = 2;
inline bool Msg::_internal_has_payload() const {
  return this != internal_default_instance() && payload_ != nullptr;
}
inline bool Msg::has_payload() const {
  return _internal_has_payload();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Msg::_internal_payload() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Msg::payload() const {
  // @@protoc_insertion_point(field_get:MyGame.Msg.payload)
  return _internal_payload();
}
inline void Msg::unsafe_arena_set_allocated_payload(
    ::PROTOBUF_NAMESPACE_ID::Any* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MyGame.Msg.payload)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Msg::release_payload() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = payload_;
  payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Msg::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:MyGame.Msg.payload)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = payload_;
  payload_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Msg::_internal_mutable_payload() {
  
  if (payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    payload_ = p;
  }
  return payload_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Msg::mutable_payload() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:MyGame.Msg.payload)
  return _msg;
}
inline void Msg::set_allocated_payload(::PROTOBUF_NAMESPACE_ID::Any* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload));
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:MyGame.Msg.payload)
}

// -------------------------------------------------------------------

// MsgRsp

// .MyGame.MsgRspHead head = 1;
inline bool MsgRsp::_internal_has_head() const {
  return this != internal_default_instance() && head_ != nullptr;
}
inline bool MsgRsp::has_head() const {
  return _internal_has_head();
}
inline void MsgRsp::clear_head() {
  if (GetArenaForAllocation() == nullptr && head_ != nullptr) {
    delete head_;
  }
  head_ = nullptr;
}
inline const ::MyGame::MsgRspHead& MsgRsp::_internal_head() const {
  const ::MyGame::MsgRspHead* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::MyGame::MsgRspHead&>(
      ::MyGame::_MsgRspHead_default_instance_);
}
inline const ::MyGame::MsgRspHead& MsgRsp::head() const {
  // @@protoc_insertion_point(field_get:MyGame.MsgRsp.head)
  return _internal_head();
}
inline void MsgRsp::unsafe_arena_set_allocated_head(
    ::MyGame::MsgRspHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MyGame.MsgRsp.head)
}
inline ::MyGame::MsgRspHead* MsgRsp::release_head() {
  
  ::MyGame::MsgRspHead* temp = head_;
  head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MyGame::MsgRspHead* MsgRsp::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:MyGame.MsgRsp.head)
  
  ::MyGame::MsgRspHead* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::MyGame::MsgRspHead* MsgRsp::_internal_mutable_head() {
  
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::MyGame::MsgRspHead>(GetArenaForAllocation());
    head_ = p;
  }
  return head_;
}
inline ::MyGame::MsgRspHead* MsgRsp::mutable_head() {
  ::MyGame::MsgRspHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:MyGame.MsgRsp.head)
  return _msg;
}
inline void MsgRsp::set_allocated_head(::MyGame::MsgRspHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:MyGame.MsgRsp.head)
}

// .google.protobuf.Any payload = 2;
inline bool MsgRsp::_internal_has_payload() const {
  return this != internal_default_instance() && payload_ != nullptr;
}
inline bool MsgRsp::has_payload() const {
  return _internal_has_payload();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& MsgRsp::_internal_payload() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& MsgRsp::payload() const {
  // @@protoc_insertion_point(field_get:MyGame.MsgRsp.payload)
  return _internal_payload();
}
inline void MsgRsp::unsafe_arena_set_allocated_payload(
    ::PROTOBUF_NAMESPACE_ID::Any* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MyGame.MsgRsp.payload)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* MsgRsp::release_payload() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = payload_;
  payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* MsgRsp::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:MyGame.MsgRsp.payload)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = payload_;
  payload_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* MsgRsp::_internal_mutable_payload() {
  
  if (payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    payload_ = p;
  }
  return payload_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* MsgRsp::mutable_payload() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:MyGame.MsgRsp.payload)
  return _msg;
}
inline void MsgRsp::set_allocated_payload(::PROTOBUF_NAMESPACE_ID::Any* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload));
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:MyGame.MsgRsp.payload)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MyGame

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MyGame::MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MyGame::MsgType>() {
  return ::MyGame::MsgType_descriptor();
}
template <> struct is_proto_enum< ::MyGame::MsgErrCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MyGame::MsgErrCode>() {
  return ::MyGame::MsgErrCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_msg_2eproto
